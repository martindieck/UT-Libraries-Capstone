import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext
import pandas as pd
import os
from xml_utils import safe_str  # Ensure this is in your import path
import xml_c02  # Ensure this is in your import path
from xml.etree.ElementTree import Element, SubElement, tostring
from xml.dom.minidom import parseString
from datetime import datetime


def create_full_xml_from_row(df, log_widget):
    """
    Convert DataFrame to XML and log progress.
    """
    # Root element of the XML document
    ead = Element('ead')
    archdesc = SubElement(
        ead, 'archdesc', level="collection", type="inventory")
    dsc = SubElement(archdesc, 'dsc')
    c01 = SubElement(dsc, 'c01', level="series")

    SubElement(SubElement(c01, 'did'), 'unittitle').text = 'Projects'

    for index, row in df.iterrows():
        log_widget.insert(
            tk.END, f"Processing row: {index + 1}, Project ID: {safe_str(row.get('unique ID', 'N/A'))}\n")
        c02_element = xml_c02.create_c02(row)
        if c02_element is not None:
            c01.append(c02_element)
        else:
            log_widget.insert(
                tk.END, "Encountered an issue with creating c02 element. Skipping.\n")

        if pd.isna(row['unique ID']):
            log_widget.insert(
                tk.END, "Detected an empty 'unique ID', stopping processing.\n")
            break

    xml_str = tostring(ead, 'utf-8')
    pretty_xml_str = parseString(xml_str).toprettyxml(indent="  ")
    return pretty_xml_str


def save_xml_to_file(xml_str, file_path):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(xml_str)


def select_file():
    filepath = filedialog.askopenfilename(
        filetypes=[("Excel files", "*.xlsx *.xls")])
    if filepath:
        file_path_entry.delete(0, tk.END)
        file_path_entry.insert(0, filepath)


def convert_and_save():
    filepath = file_path_entry.get()
    if not filepath:
        messagebox.showerror("Error", "No file selected!")
        return

    try:
        df = pd.read_excel(filepath)
        xml_output = create_full_xml_from_row(df, log_text)
        save_file_path = filedialog.asksaveasfilename(filetypes=[(
            "XML files", "*.xml")], defaultextension=".xml", initialfile="output.xml")
        if save_file_path:
            save_xml_to_file(xml_output, save_file_path)
            messagebox.showinfo(
                "Success", f"XML has been saved to {save_file_path}")
        else:
            messagebox.showinfo("Cancelled", "Save cancelled.")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to convert: {str(e)}")


app = tk.Tk()
app.title("XML Conversion Tool")

tk.Label(app, text="File Path:").pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)
file_path_entry = tk.Entry(app, width=50)
file_path_entry.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)
select_file_button = tk.Button(app, text="Select File", command=select_file)
select_file_button.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)
convert_button = tk.Button(
    app, text="Convert to XML", command=convert_and_save)
convert_button.pack(side=tk.TOP, fill=tk.X, padx=10, pady=10)

log_text = scrolledtext.ScrolledText(app, height=10)
log_text.pack(side=tk.TOP, fill=tk.X, padx=10, pady=10)

tk.Label(app, text="Usage Tips:").pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)
usage_tips = "Choose an Excel file and then click 'Convert to XML' to create the XML file. Save the result by selecting a location. The column names in the input of this converter should match those in the output file generated by the cleaning code."
tips_text = tk.Text(app, height=4)
tips_text.insert(tk.END, usage_tips)
tips_text.config(state=tk.DISABLED)
tips_text.pack(side=tk.TOP, fill=tk.X, padx=10, pady=10)

app.mainloop()
